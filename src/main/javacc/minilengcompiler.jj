options
{
  static = true;
  ignore_case = true;
  common_token_action = true;
  debug_parser = false;
  java_unicode_escape = true;
}

PARSER_BEGIN(MiniLeng)
package com.minileng.generated;

import com.minileng.collections.FollowSets;
import com.minileng.collections.KindNameMapping;
import java.util.Set;
import com.minileng.collections.TokenFreq;
import com.minileng.exceptions.UnknownTokenException;
import com.minileng.semantic.Symbol;
import com.minileng.semantic.SymbolTable;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public class MiniLeng {

  /**
   * Simple class is used to indicate if an expression is a constant (e.g., 3 + 3 + 4) and
   * the value of that expression (e.g., 10) or if isn't a constant expression (e.g., 3 + id)
   */
  private static class Constexpr {
    public boolean isConst;
    public int value;
    public Constexpr(boolean isConst, int value) {
      this.isConst = isConst;
      this.value = value;
    }
    public Constexpr(boolean isConst) {
      this.isConst = isConst;
      this.value = -1;
    }
    public Constexpr() {
      this.isConst = false;
      this.value = -1;
    }
  }

  private static final Logger LOG = LogManager.getLogger();

  public static String buildMessage(ParseException e) {
    StringBuffer expected = new StringBuffer();
    int maxSize = 0;
    for (int i = 0; i < e.expectedTokenSequences.length; i++) {
      if (maxSize < e.expectedTokenSequences[i].length) {
        maxSize = e.expectedTokenSequences[i].length;
      }
      for (int j = 0; j < e.expectedTokenSequences[i].length; j++) {
        expected.append("<")
            .append(KindNameMapping.getInstance().name(e.expectedTokenSequences[i][j])).append(">")
            .append(", ");
      }
    }
    expected.delete(expected.length() - 2, expected.length());
    String retval = "Encontrado \"";
    Token tok = e.currentToken.next;
    for (int i = 0; i < maxSize; i++) {
      if (i != 0) {
        retval += " ";
      }
      if (tok.kind == 0) {
        retval += tokenImage[0];
        break;
      }
      retval += "<" + KindNameMapping.getInstance().name(tok.kind) + ">";
      retval += ":=";
      retval += ParseException.add_escapes(tok.image);
      retval += "\"";
      tok = tok.next;
    }
    retval += ". ";

    if (e.expectedTokenSequences.length == 0) {
      // Nothing to add here
    } else {
      if (e.expectedTokenSequences.length == 1) {
        retval += "Se esperaba: ";
      } else {
        retval += "Se esperaba uno de: ";
      }
      retval += expected.toString() + ".";
    }
    return retval;
  }

  public static void recoverParsingError(String nonterminal, ParseException e) {
    LOG.error("ERROR SINTÁCTICO({}, {}): {}", e.currentToken.next.beginLine,
      e.currentToken.next.beginColumn, buildMessage(e));
    Set<String> followSet = FollowSets.getFollowSet(nonterminal);
    int pos;
    for (pos = 2; !followSet.contains(KindNameMapping.getInstance().name(getToken(pos).kind)) ; ++pos);
    for (int i = 0; i < pos - 1; ++i) getNextToken();
  }

  public static Symbol.VariableType toVariableType(int kind) {
    Symbol.VariableType type;
    switch(kind) {
      case tENTERO:
        type = Symbol.VariableType.INT;
        break;
      case tCARACTER:
        type = Symbol.VariableType.CHAR;
        break;
      case tBOOLEANO:
        type = Symbol.VariableType.BOOL;
        break;
      default:
        type = Symbol.VariableType.UNKNOWN;
        break;
    }
    return type;
  }

  private static void addIdsSymbolTable(Symbol.SymbolType symbolType,
      Symbol.VariableType variableType, Symbol.ParameterType parameterType, Token id) {
    if (symbolType == null) {
      Symbol s = SymbolTable.getInstance().get(id.image);
      if (s == null) {
        LOG.info("ERROR SEM\u00c1NTICO({}, {}): Simbolo no declarado: \"{}\"", id.beginLine,
            id.beginColumn, id.image);
      }
    } else if (symbolType == Symbol.SymbolType.VARIABLE) {
      if(!SymbolTable.getInstance().putVariable(id.image, variableType)) {
        LOG.info("ERROR SEM\u00c1NTICO({}, {}): Simbolo ya declarado previamente: \"{}\"",
            id.beginLine, id.beginColumn, id.image);
      }
    } else if (symbolType == Symbol.SymbolType.PARAMETER) {
      if (variableType == null) {
        variableType = Symbol.VariableType.UNKNOWN;
      }
      if(!SymbolTable.getInstance().putParameter(id.image, variableType, parameterType)) {
        LOG.error("We should never arrive here because a new scope should've been created immediately before.");
      }
    }
  }

  private static boolean relation(Token relToken, int a, int b) {
    switch (relToken.kind ) {
      case tMAYOR:
        return a > b;
      case tMENOR:
        return a < b;
      case tIGUAL:
        return a == b;
      case tMAI:
        return a >= b;
      case tMEI:
        return a <= b;
      case tNI:
        return a != b;
      default:
        return false;
    }
  }

}

PARSER_END(MiniLeng)

TOKEN_MGR_DECLS :
{
  private static TokenFreq tokenFreq = new TokenFreq();

  public static TokenFreq getTokenFreq() {
    return tokenFreq;
  }

  static void CommonTokenAction(Token t) {
    tokenFreq.addOrInc(t.kind);
  }
}

SKIP :
{
  " "
  | "\t"
  | "\n"
  | "\r"
  | "\r\n"
  | < tCOMENTARIO: "%"(~["\n","\r"])*("\n"|"\r"|"\r\n") >
}

// Data types
TOKEN :
{
  < tENTERO : "entero" >
  | < tBOOLEANO : "booleano" >
  | < tCARACTER : "caracter" >
}

// Arithmetic operators
TOKEN :
{
  < tMAS : "+" >
  | < tMENOS : "-" >
  | < tMUL : "*" >
  | < tDIVCHAR : "/" >
  | < tDIV : "div" >
  | < tMOD : "mod" >
}

// Asignment operators
TOKEN :
{
  < tOPAS : ":=" >
}

// Relational operators
TOKEN :
{
  < tMAYOR : ">" >
  | < tMENOR : "<" >
  | < tIGUAL : "=" >
  | < tMAI : ">=" >
  | < tMEI : "<=" >
  | < tNI : "<>" >
}

// Logical operators
TOKEN :
{
  < tAND : "and" >
  | < tOR : "or" >
  | < tNOT : "not" >
}

// Casting operators
TOKEN :
{
  < tENTACAR : "entacar" >
  | < tCARAENT : "caraent" >
}

// Conditional structures
TOKEN :
{
  < tSI : "si" >
  | < tENT : "ent" >
  | < tSI_NO : "si_no" >
  | < tFSI : "fsi" >
  | < tMQ : "mq" >
  | < tFMQ : "fmq" >
}

// IO
TOKEN :
{
  < tESCRIBIR : "escribir" >
  | < tLEER : "leer" >
}

// Procedure related tokens
TOKEN :
{
  < tVAL : "val" >
  | < tREF : "ref" >
  | < tACCION : "accion" >
  | < tPRINCIPIO : "principio" >
  | < tFIN : "fin" >
}

// Constants
TOKEN :
{
  < tTRUE : "true" >
  | < tFALSE : "false" >
  | < tKENTERO : (["0"-"9"])+ >
  | < tKCARACTER: "\""(~["\n","\r"])"\"" >
  | < tKCADENA: "\""(~["\n","\r","\""])(~["\n","\r","\""])+"\"" >
  | < tPUNTOCOMA : ";" >
  | < tCOMA : "," >
  | < tPAR_DCHA : ")" >
  | < tPAR_IZQ : "(" >
}

// Program
TOKEN :
{
  < tPROGRAMA : "programa" >
  | < tID : (["a"-"z"]) | (["a"-"z","_"](["a"-"z","0"-"9","_"])*(["a"-"z","0"-"9"])+) >
}

// Error
TOKEN :
{
  < tERROR : ~[] >
  {
    if (true) {
      throw new UnknownTokenException(
          "ERROR LÉXICO (" + matchedToken.beginLine + ", " + matchedToken.beginColumn
              + "): símbolo no reconocido: " + image);
    }
  }
}

void programa() :
{
  Token p;
}

{
  try {
    <tPROGRAMA> { SymbolTable.getInstance().openScope(); }
    p = <tID> { SymbolTable.getInstance().putProgram(p.image); }
    <tPUNTOCOMA> declaracion_variables() declaracion_acciones() bloque_sentencias()
    { SymbolTable.getInstance().closeScope(); }
  } catch (UnknownTokenException e) {
    LOG.error(e.getMessage());
  } catch (ParseException e) {
    recoverParsingError("programa", e);
  }
}

void declaracion_variables() :
{
}

{
  try {
    declaracion() <tPUNTOCOMA> declaracion_variables() | {}
  } catch (ParseException e) {
    recoverParsingError("declaracion_variables", e);
  }
}

void declaracion() :
{
  Symbol.SymbolType symbolType = Symbol.SymbolType.VARIABLE;
  Symbol.VariableType variableType;
}

{
  try {
    variableType = tipo_variables() identificadores(symbolType, variableType, null, null)
  } catch (ParseException e) {
    recoverParsingError("declaracion", e);
  }
}

Symbol.VariableType tipo_variables() :
{
  Token t = null;
}

{
  try {
    t = <tENTERO> | t = <tCARACTER> | t = <tBOOLEANO>
  } catch (ParseException e) {
    recoverParsingError("tipo_variables", e);
  }
  { return t == null ? null : toVariableType(t.kind); }
}

/**
 * @param symbolType the type of symbol with whom the ids are going to be associated. If null, it
 * means that nothing should be added to the symbol table.
 * @param variableType the type of the variable
 * @param parameterType the type of the parameter. null if {@code symbolType} is not {@code
 * SymbolType.PARAMETER}
 * @param actionName the name of the action with whom a parameter is associated. null if {@code
 * symbolType} is not {@code SymbolType.PARAMETER}
 * @throws ParseException will never be thrown because we do error recovery
 */
void identificadores(Symbol.SymbolType symbolType, Symbol.VariableType variableType,
    Symbol.ParameterType parameterType, String actionName) :
{
  Token id;
}

{
  try {
    id = <tID>
    {
      addIdsSymbolTable(symbolType, variableType, parameterType, id);
    }
    repeticion_identificadores(symbolType, variableType, parameterType, actionName)
  } catch (ParseException e) {
    recoverParsingError("identificadores", e);
  }
}

/**
 * @see #identificadores() for the explanation on the parameters.
 */
void repeticion_identificadores(Symbol.SymbolType symbolType, Symbol.VariableType variableType,
    Symbol.ParameterType parameterType, String actionName) :
{
  Token id;
}

{
  try {
    <tCOMA> id = <tID>
    {
      addIdsSymbolTable(symbolType, variableType, parameterType, id);
    }
    repeticion_identificadores(symbolType, variableType, parameterType, actionName) | {}
  } catch (ParseException e) {
    recoverParsingError("repeticion_identificadores", e);
  }
}

void declaracion_acciones() :
{
}

{
  try {
    declaracion_accion() declaracion_acciones() | {}
  } catch (ParseException e) {
    recoverParsingError("declaracion_acciones", e);
  }
}

void declaracion_accion() :
{
  String actionName;
}

{
  try {
    actionName = cabecera_accion() <tPUNTOCOMA> declaracion_variables() declaracion_acciones()
    bloque_sentencias()
    {
      SymbolTable.getInstance().closeScope();
    }
  } catch (ParseException e) {
    recoverParsingError("declaracion_accion", e);
  }
}

String cabecera_accion() :
{
  Token id = null;
}

{
  try {
    <tACCION> id = <tID>
    {
      if(!SymbolTable.getInstance().putAction(id.image)) {
        LOG.info("ERROR SEM\u00c1NTICO({}, {}): Simbolo ya declarado previamente: \"{}\"",
            id.beginLine, id.beginColumn, id.image);
      }
      SymbolTable.getInstance().openScope();
    }
    parametros_formales(id.image)
  } catch (ParseException e) {
    recoverParsingError("cabecera_accion", e);
  }
  {return id == null ? null : id.image;}
}

void parametros_formales(String actionName) :
{
}

{
  try {
    <tPAR_IZQ> lista_parametros(actionName) <tPAR_DCHA> | {}
  } catch (ParseException e) {
    recoverParsingError("parametros_formales", e);
  }
}

void lista_parametros(String actionName) :
{
}

{
  try {
    parametro(actionName) repeticion_parametro(actionName) | {}
  } catch (ParseException e) {
    recoverParsingError("lista_parametros", e);
  }
}

void parametro(String actionName) :
{
  Symbol.SymbolType symbolType = Symbol.SymbolType.PARAMETER;
  Symbol.ParameterType parameterType;
  Symbol.VariableType variableType;
}

{
  try {
    parameterType = clase_parametros() variableType = tipo_variables()
    identificadores(symbolType, variableType, parameterType, actionName)
  } catch (ParseException e) {
    recoverParsingError("parametro", e);
  }
}

void repeticion_parametro(String actionName) :
{
}

{
  try {
    <tPUNTOCOMA> parametro(actionName) repeticion_parametro(actionName) | {}
  } catch (ParseException e) {
    recoverParsingError("repeticion_parametro", e);
  }
}

Symbol.ParameterType clase_parametros() :
{
  Symbol.ParameterType parameterType = null;
}

{
  try {
    <tVAL> {parameterType = Symbol.ParameterType.VAL;}
    | <tREF> {parameterType = Symbol.ParameterType.REF;}
  } catch (ParseException e) {
    recoverParsingError("clase_parametros", e);
  }
  {return parameterType;}
}

void bloque_sentencias() :
{
}

{
  try {
    <tPRINCIPIO> lista_sentencias() <tFIN>
  } catch (ParseException e) {
    recoverParsingError("bloque_sentencias", e);
  }
}

void lista_sentencias() :
{
}

{
  try {
    sentencia() lista_sentencias() | {}
  } catch (ParseException e) {
    recoverParsingError("lista_sentencias", e);
  }
}

void sentencia() :
{
}

{
  try {
    leer() <tPUNTOCOMA> | escribir() <tPUNTOCOMA> | asignacion_invocacion() | seleccion() | mientras_que()
  } catch (ParseException e) {
    recoverParsingError("sentencia", e);
  }
}

void leer() :
{
}

{
  try {
    <tLEER> <tPAR_IZQ> identificadores(null, null, null, null) <tPAR_DCHA>
  } catch (ParseException e) {
    recoverParsingError("leer", e);
  }
}

void escribir() :
{
}

{
  try {
    <tESCRIBIR> <tPAR_IZQ> lista_argumentos_no_vacia() <tPAR_DCHA>
  } catch (ParseException e) {
    recoverParsingError("escribir", e);
  }
}

void asignacion_invocacion() :
{
  Token id;
}

{
  try {
    id = <tID>
    {
      if (SymbolTable.getInstance().get(id.image) == null) {
        LOG.info("ERROR SEM\u00c1NTICO({}, {}): Simbolo no declarado: \"{}\"", id.beginLine,
            id.beginColumn, id.image);
      }
    }
    asignacion_invocacion_()
  } catch (ParseException e) {
    recoverParsingError("asignacion_invocacion", e);
  }
}

void asignacion_invocacion_() :
{
}

{
  try {
    asignacion() | invocacion_accion()
  } catch (ParseException e) {
    recoverParsingError("asignacion_invocacion_", e);
  }
}

void asignacion() :
{
}

{
  try {
    <tOPAS> argumento() <tPUNTOCOMA>
  } catch (ParseException e) {
    recoverParsingError("asignacion", e);
  }
}

void invocacion_accion() :
{
}

{
  try {
    argumentos_accion() <tPUNTOCOMA>
  } catch (ParseException e) {
    recoverParsingError("invocacion_accion", e);
  }
}

void mientras_que() :
{
}

{
  try {
    <tMQ> expresion_bool() lista_sentencias() <tFMQ>
  } catch (ParseException e) {
    recoverParsingError("mientras_que", e);
  }
}

void seleccion() :
{
}

{
  try {
    <tSI> seleccion_()
  } catch (ParseException e) {
    recoverParsingError("seleccion", e);
  }
}

void argumentos_accion() :
{
}

{
  try {
    <tPAR_IZQ> lista_argumentos_vacia() <tPAR_DCHA> | {}
  } catch (ParseException e) {
    recoverParsingError("argumentos_accion", e);
  }
}

void argumento() :
{
}

{
  try {
    <tKCADENA> | entacar() | expresion_bool()
  } catch (ParseException e) {
    recoverParsingError("argumento", e);
  }
}

void lista_argumentos_vacia() :
{
}

{
  try {
    <tKCADENA> repeticion_argumentos() | entacar() repeticion_argumentos() | expresion_bool() repeticion_argumentos()  | {}
  } catch (ParseException e) {
    recoverParsingError("lista_argumentos_vacia", e);
  }
}

void lista_argumentos_no_vacia() :
{
}

{
  try {
    <tKCADENA> repeticion_argumentos() | entacar() repeticion_argumentos() | expresion_bool() repeticion_argumentos()
  } catch (ParseException e) {
    recoverParsingError("lista_argumentos_no_vacia", e);
  }
}

void repeticion_argumentos() :
{
}

{
  try {
    <tCOMA> argumento() repeticion_argumentos() | {}
  } catch (ParseException e) {
    recoverParsingError("repeticion_argumentos", e);
  }
}

Token operador_relacional() :
{
  Token t = null;
}

{
  try {
    t = <tMAYOR> | t = <tMENOR> | t = <tIGUAL> | t = <tMAI> | t = <tMEI> | t = <tNI>
  } catch (ParseException e) {
    recoverParsingError("operador_relacional", e);
  }
  {return t;}
}

void caraent() :
{
}

{
  try {
    <tCARAENT> caraent_()
  } catch (ParseException e) {
    recoverParsingError("caraent", e);
  }
}

Constexpr entacar() :
{
   Constexpr constexpr = new Constexpr();
   Token t;
}

{
  try {
    t = <tENTACAR> <tPAR_IZQ> constexpr = expresion_bool()
    {
      if (constexpr.isConst && (constexpr.value < 0 || constexpr.value > 255)) {
        LOG.info("ERROR SEM\u00c1NTICO({}, {}): El argumento de 'entacar' ha de tener un valor"
            + "comprendido entre 0 y 255, ambos incluidos", t.beginLine, t.beginColumn);
      }
    }
    <tPAR_DCHA>
  } catch (ParseException e) {
    recoverParsingError("entacar", e);
  }
  {return constexpr;}
}

Constexpr expresion_bool() :
{
  Constexpr constexprTermBool = new Constexpr();
  Constexpr constexprExpresionBool = new Constexpr();
}

{
  try {
    constexprTermBool = term_bool() constexprExpresionBool = expresion_bool_(constexprTermBool)
  } catch (ParseException e) {
    recoverParsingError("expresion_bool", e);
  }
  {return constexprExpresionBool;}
}

Constexpr term_bool() :
{
  Constexpr factor = new Constexpr();
  Constexpr term = new Constexpr();
}

{
  try {
    factor = factor_bool_unario() term = term_bool_(factor)
  } catch (ParseException e) {
    recoverParsingError("term_bool", e);
  }
  {return term;}
}

Constexpr factor_bool_unario() :
{
  Constexpr constexpr = new Constexpr();
}

{
  try {
    <tNOT> constexpr = factor_bool() {constexpr.value = constexpr.value != 0 ? 0 : 1;}
    | constexpr = factor_bool()
  } catch (ParseException e) {
    recoverParsingError("factor_bool_unario", e);
  }
  {return constexpr;}
}

Constexpr factor_bool() :
{
  Constexpr constexpr = new Constexpr();
}

{
  try {
    <tFALSE> {constexpr.isConst = true; constexpr.value = 0;}
    | <tTRUE> {constexpr.isConst = true; constexpr.value = 1;}
    | constexpr = relacion()
  } catch (ParseException e) {
    recoverParsingError("factor_bool", e);
  }
  {return constexpr;}
}

Constexpr relacion() :
{
  Constexpr constexpr = new Constexpr();
  Constexpr expr = new Constexpr();
  Constexpr rel = new Constexpr();
}

{
  try {
    expr = expresion_arit() rel = relacion_(expr) {constexpr = rel;}
  } catch (ParseException e) {
    recoverParsingError("relacion", e);
  }
  {return constexpr;}
}

Constexpr expresion_arit() :
{
  Constexpr constexpr = new Constexpr();
  Constexpr term = new Constexpr();
  Constexpr exp = new Constexpr();
}

{
  try {
    term = term_arit() exp = expresion_arit_(term)
  } catch (ParseException e) {
    recoverParsingError("expresion_arit", e);
  }
  {return exp;}
}

Constexpr term_arit() :
{
  Constexpr constexpr = new Constexpr();
  Constexpr factor = new Constexpr();
  Constexpr term = new Constexpr();
}

{
  try {
    factor = factor_arit_unario() term = term_arit_(factor)
  } catch (ParseException e) {
    recoverParsingError("term_arit", e);
  }
  {return term;}
}

Constexpr factor_arit_unario() :
{
  Constexpr constexpr = new Constexpr();
}

{
  try {
    <tMAS> constexpr = factor_arit()
    | <tMENOS> constexpr = factor_arit() {constexpr.value = -1 * constexpr.value;}
    | constexpr = factor_arit()
  } catch (ParseException e) {
    recoverParsingError("factor_arit_unario", e);
  }
  {return constexpr;}
}

Constexpr factor_arit() :
{
  Token id;
  Constexpr constexpr = new Constexpr();
}

{
  try {
    id = <tKENTERO> {constexpr.isConst = true; constexpr.value = Integer.valueOf(id.image);}
    | id = <tID>
    {
      if (SymbolTable.getInstance().get(id.image) == null) {
        LOG.info("ERROR SEM\u00c1NTICO({}, {}): Simbolo no declarado: \"{}\"", id.beginLine,
            id.beginColumn, id.image);
      }
    }
    | id = <tKCARACTER> {constexpr.isConst = true; constexpr.value = id.image.charAt(0);}
    | <tPAR_IZQ> constexpr = expresion_bool() <tPAR_DCHA>
    | <tCARAENT> constexpr = factor_arit_()
  } catch (ParseException e) {
    recoverParsingError("factor_arit", e);
  }
  {return constexpr;}
}

Constexpr expresion_bool_(Constexpr inherit) :
{
  Constexpr constexpr = new Constexpr();
  Constexpr term = new Constexpr();
  Constexpr exp = new Constexpr();
}

{
  try {
    <tOR> term = term_bool() exp = expresion_bool_(term)
    {
      constexpr.isConst = inherit.isConst && exp.isConst;
      constexpr.value = (inherit.value != 0) || (exp.value != 0) ? 1 : 0;
    }
    | {} {constexpr = inherit;}
  } catch (ParseException e) {
    recoverParsingError("expresion_bool_", e);
  }
  {return constexpr;}
}

Constexpr term_bool_(Constexpr inherit) :
{
  Constexpr constexpr = new Constexpr();
  Constexpr factor = new Constexpr();
  Constexpr term = new Constexpr();
}

{
  try {
    <tAND> factor = factor_bool_unario() term = term_bool_(factor)
    {
      constexpr.isConst = inherit.isConst && term.isConst;
      constexpr.value = (inherit.value != 0) && (term.value != 0) ? 1 : 0;
    }
    | {} {constexpr = inherit;}
  } catch (ParseException e) {
    recoverParsingError("term_bool_", e);
  }
  {return constexpr;}
}

Constexpr expresion_arit_(Constexpr inherit) :
{
  Constexpr constexpr = new Constexpr();
  Constexpr term = new Constexpr();
  Constexpr exp = new Constexpr();
}

{
  try {
    <tMAS> term = term_arit() exp = expresion_arit_(term)
    {
      constexpr.isConst = inherit.isConst && term.isConst && exp.isConst;
      constexpr.value = inherit.value + exp.value;
    }
    | <tMENOS> term = term_arit() exp = expresion_arit_(term)
    {
      constexpr.isConst = inherit.isConst && term.isConst && exp.isConst;
      constexpr.value = inherit.value - exp.value;
    }
    | {} {constexpr = inherit;}
  } catch (ParseException e) {
    recoverParsingError("expresion_arit_", e);
  }
  {return constexpr;}
}

Constexpr term_arit_(Constexpr inherit) :
{
    Constexpr constexpr = new Constexpr();
    Constexpr factor = new Constexpr();
    Constexpr term = new Constexpr();
    Token t;
}

{
  try {
    <tMUL> factor = factor_arit_unario() term = term_arit_(factor)
    {
      if (inherit.isConst && factor.isConst) {
        constexpr.isConst = true;
        constexpr.value = inherit.value * term.value;
      } else if ((inherit.isConst && inherit.value == 0)
            || (factor.isConst && factor.value == 0)) {
        constexpr.isConst = true;
        constexpr.value = 0;
      }
    }
    | t = <tDIV> factor = factor_arit_unario() term = term_arit_(factor)
    {
      if (term.isConst) {
        if (term.value == 0) {
          LOG.info("ERROR SEM\u00c1NTICO({}, {}): Division por cero", t.beginLine, t.beginColumn);
        } else {
          constexpr.isConst = inherit.isConst && term.isConst && factor.isConst;
          constexpr.value = inherit.value / term.value;
        }
      }
    }
    | t = <tDIVCHAR> factor = factor_arit_unario() term = term_arit_(factor)
    {
      if (term.isConst) {
        if (term.value == 0) {
          LOG.info("ERROR SEM\u00c1NTICO({}, {}): Division por cero", t.beginLine, t.beginColumn);
        } else {
          constexpr.isConst = inherit.isConst && term.isConst && factor.isConst;
          constexpr.value = inherit.value / term.value;
        }
      }
    }
    | t = <tMOD> factor = factor_arit_unario() term = term_arit_(factor)
    {
      if (term.isConst && term.value == 0) {
        LOG.info("ERROR SEM\u00c1NTICO({}, {}): Modulo cero", t.beginLine, t.beginColumn);
      } else {
        constexpr.isConst = inherit.isConst && term.isConst && factor.isConst;
        constexpr.value = inherit.value % term.value;
      }
    }
    | {} {constexpr = inherit;}
  } catch (ParseException e) {
    recoverParsingError("term_arit_", e);
  }
  {return constexpr;}
}

void seleccion_() :
{
}

{
  try {
    expresion_bool() seleccion__()
  } catch (ParseException e) {
    recoverParsingError("seleccion_", e);
  }
}

Constexpr caraent_() :
{
  Constexpr constexpr = new Constexpr();
}

{
  try {
    <tPAR_IZQ> constexpr = caraent__()
  } catch (ParseException e) {
    recoverParsingError("caraent_", e);
  }
  {return constexpr;}
}

Constexpr relacion_(Constexpr inherit) :
{
  Constexpr constexpr = new Constexpr();
  Constexpr exp = new Constexpr();
  Token op;
}

{
  try {
    op = operador_relacional() exp = expresion_arit()
    {
      constexpr.value = relation(op, inherit.value, exp.value) ? 1 : 0;
      constexpr.isConst = inherit.isConst && exp.isConst;
    }
    | {} {constexpr = inherit;}
  } catch (ParseException e) {
    recoverParsingError("relacion_", e);
  }
  {return constexpr;}
}

Constexpr factor_arit_() :
{
  Constexpr constexpr = new Constexpr();
}

{
  try {
    <tPAR_IZQ> constexpr = factor_arit__()
  } catch (ParseException e) {
    recoverParsingError("factor_arit_", e);
  }
  {return constexpr;}
}

void seleccion__() :
{
}

{
  try {
    <tENT> seleccion___()
  } catch (ParseException e) {
    recoverParsingError("seleccion__", e);
  }
}

Constexpr caraent__() :
{
  Token id;
  Constexpr constexpr = new Constexpr();
}

{
  try {
    id = <tKCARACTER> <tPAR_DCHA> {constexpr.isConst = true; constexpr.value = id.image.charAt(0);}
    | constexpr = entacar() <tPAR_DCHA>
    | id = <tID>
    {
      if (SymbolTable.getInstance().get(id.image) == null) {
        LOG.info("ERROR SEM\u00c1NTICO({}, {}): Simbolo no declarado: \"{}\"", id.beginLine,
            id.beginColumn, id.image);
      }
    }
    <tPAR_DCHA>
  } catch (ParseException e) {
    recoverParsingError("caraent__", e);
  }
  {return constexpr;}
}

Constexpr factor_arit__() :
{
  Token id;
  Constexpr constexpr = new Constexpr();
}

{
  try {
    id = <tKCARACTER> <tPAR_DCHA> {constexpr.isConst = true; constexpr.value = id.image.charAt(0);}
    | constexpr = entacar() <tPAR_DCHA>
    | id = <tID>
    {
      if (SymbolTable.getInstance().get(id.image) == null) {
        LOG.info("ERROR SEM\u00c1NTICO({}, {}): Simbolo no declarado: \"{}\"", id.beginLine,
            id.beginColumn, id.image);
      }
    }
    <tPAR_DCHA>
  } catch (ParseException e) {
    recoverParsingError("factor_arit__", e);
  }
  {return constexpr;}
}

void seleccion___() :
{
}

{
  try {
    lista_sentencias() seleccion____()
  } catch (ParseException e) {
    recoverParsingError("seleccion___", e);
  }
}

void seleccion____() :
{
}

{
  try {
    <tFSI> | <tSI_NO> lista_sentencias() <tFSI>
  } catch (ParseException e) {
    recoverParsingError("seleccion____", e);
  }
}