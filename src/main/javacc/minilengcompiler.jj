options
{
  static = true;
  ignore_case = true;
  common_token_action = true;
  debug_parser = false;
  java_unicode_escape = true;
}

PARSER_BEGIN(MiniLeng)
package com.minileng.generated;

import com.minileng.collections.FollowSets;
import com.minileng.collections.KindNameMapping;
import java.util.Set;
import java.util.ArrayList;
import java.util.List;
import java.io.IOException;
import com.minileng.codegen.CodeGenerator;
import com.minileng.collections.TokenFreq;
import com.minileng.exceptions.UnknownTokenException;
import com.minileng.semantic.Symbol;
import com.minileng.semantic.SymbolTable;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public class MiniLeng {

  private static class Expr {
    public boolean isConst;
    public int value;
    public boolean isLValue;
    public Symbol sym;
    public Symbol.VariableType type;

    public Expr(boolean isConst, int value, boolean isLValue) {
      this.isConst = isConst;
      this.value = value;
      this.isLValue = isLValue;
    }
    public Expr(boolean isConst, int value) {
      this.isConst = isConst;
      this.value = value;
      this.isLValue = false;
    }
    public Expr(boolean isConst) {
      this.isConst = isConst;
      this.value = -1;
    }
    public Expr() {
      this.isConst = false;
      this.value = -1;
      this.isLValue = false;
      this.type = Symbol.VariableType.UNK;
    }
  }

  private static class ParamsInfo {
    Symbol.ParameterType parType;
    Symbol.VariableType varType;
    List<Token> idTokens;
  }

  private static class IntWrapper {
    int value;
    public IntWrapper() {
      value = 3;
    }
    public IntWrapper(int value) {
      this.value = value;
    }
  }

  private static final Logger LOG = LogManager.getLogger();

  private static String buildMessage(ParseException e) {
    StringBuffer expected = new StringBuffer();
    int maxSize = 0;
    for (int i = 0; i < e.expectedTokenSequences.length; i++) {
      if (maxSize < e.expectedTokenSequences[i].length) {
        maxSize = e.expectedTokenSequences[i].length;
      }
      for (int j = 0; j < e.expectedTokenSequences[i].length; j++) {
        expected.append("<")
            .append(KindNameMapping.getInstance().name(e.expectedTokenSequences[i][j])).append(">")
            .append(", ");
      }
    }
    expected.delete(expected.length() - 2, expected.length());
    String retval = "Encontrado \"";
    Token tok = e.currentToken.next;
    for (int i = 0; i < maxSize; i++) {
      if (i != 0) {
        retval += " ";
      }
      if (tok.kind == 0) {
        retval += tokenImage[0];
        break;
      }
      retval += "<" + KindNameMapping.getInstance().name(tok.kind) + ">";
      retval += ":=";
      retval += ParseException.add_escapes(tok.image);
      retval += "\"";
      tok = tok.next;
    }
    retval += ". ";

    if (e.expectedTokenSequences.length == 0) {
      // Nothing to add here
    } else {
      if (e.expectedTokenSequences.length == 1) {
        retval += "Se esperaba: ";
      } else {
        retval += "Se esperaba uno de: ";
      }
      retval += expected.toString() + ".";
    }
    return retval;
  }

  private static void recoverParsingError(String nonterminal, ParseException e) {
    isThereAParsingError = true;
    LOG.info("ERROR SINTÁCTICO({}, {}): {}", e.currentToken.next.beginLine,
      e.currentToken.next.beginColumn, buildMessage(e));
    Set<String> followSet = FollowSets.getFollowSet(nonterminal);
    int pos;
    for (pos = 1; !followSet.contains(KindNameMapping.getInstance().name(getToken(pos).kind)) ; ++pos);
    for (int i = 0; i < pos - 1; ++i) getNextToken();
  }

  private static Symbol.VariableType toVariableType(int kind) {
    Symbol.VariableType type;
    switch(kind) {
      case tENTERO:
        type = Symbol.VariableType.INT;
        break;
      case tCARACTER:
        type = Symbol.VariableType.CHAR;
        break;
      case tBOOLEANO:
        type = Symbol.VariableType.BOOL;
        break;
      default:
        type = Symbol.VariableType.UNK;
        break;
    }
    return type;
  }

  private static boolean relation(Token relToken, int a, int b) {
    switch (relToken.kind ) {
      case tMAYOR:
        return a > b;
      case tMENOR:
        return a < b;
      case tIGUAL:
        return a == b;
      case tMAI:
        return a >= b;
      case tMEI:
        return a <= b;
      case tNI:
        return a != b;
      default:
        return false;
    }
  }

  private static boolean checkIfSymbolExists(Token token) {
    Symbol sym = SymbolTable.getInstance().get(token.image);
    if (sym != null) {
      return true;
    }
    LOG.info("ERROR SEMÁNTICO({}, {}): Simbolo no declarado: \"{}\"", token.beginLine,
        token.beginColumn, token.image);
    isThereASemanticError = true;
    /* SymbolTable.getInstance().putVariable(token.image, Symbol.VariableType.UNK, -1); */
    return false;
  }

  private static boolean checkIfItsVarOrParam(Token token) {
    Symbol sym = SymbolTable.getInstance().get(token.image);
    if (sym.isVariable() || sym.isParameter())  {
      return true;
    }
    LOG.info("ERROR SEMÁNTICO({}, {}): El simbolo no es una variable o un parámetro: \"{}\"",
        token.beginLine, token.beginColumn, token.image);
    isThereASemanticError = true;
    return false;
  }

  public static boolean checkIfItsAssignable(Token token) {
    Symbol sym = SymbolTable.getInstance().get(token.image);
    if (sym.isVariable() || sym.isReference()) {
      return true;
    }
    LOG.info("ERROR SEMÁNTICO({}, {}): El simbolo no es una variable o un parámetro calificado con \"ref\": \"{}\"",
        token.beginLine, token.beginColumn, token.image);
    isThereASemanticError = true;
    return false;
  }

  public static boolean checkIfArgIsValid(Expr arg, Symbol param, Token t) {
    if (param.isReference() && (!arg.isLValue || arg.sym.isValue())) {
      LOG.info("ERROR SEMÁNTICO({}, {}): No se puede pasar un rvalue a un parametero calificado con \"ref\"",
          t.beginLine, t.beginColumn);
      isThereASemanticError = true;
      return false;
    }
    return true;
  }

  public static boolean checkArgAndParamTypes(Expr arg, Symbol param, Token t) {
    if (param.getVariableType() == arg.type ||
          param.getVariableType() == Symbol.VariableType.UNK ||
          arg.type == Symbol.VariableType.UNK) {
      return true;
    }
    LOG.info("ERROR SEMÁNTICO({}, {}): Se esperaba un argumento del tipo {}, pero se ha obtenido uno del tipo {}",
        t.beginLine, t.beginColumn, param.getVariableType(), arg.type);
    isThereASemanticError = true;
    return false;
  }

  public static boolean checkCaraentArg(Expr arg, Token t) {
    if (arg.type != Symbol.VariableType.CHAR) {
      LOG.info("ERROR SEMÁNTICO({}, {}): El argumento de 'caraent' ha de ser del tipo caracter", t.beginLine, t.beginColumn);
      isThereASemanticError = true;
      return false;
    }
    return true;
  }

  public static boolean checkEntacarArgType(Expr arg, Token t) {
    if (arg.type != Symbol.VariableType.INT) {
      LOG.info("ERROR SEMÁNTICO({}, {}): El argumento de 'entacar' ha de ser del tipo entero", t.beginLine, t.beginColumn);
      isThereASemanticError = true;
      return false;
    }
    return true;
  }

  public static boolean checkEntacarArgConstValue(Expr arg, Token t) {
    if (arg.isConst && (arg.value < 0 || arg.value > 255)) {
      LOG.info("ERROR SEMÁNTICO({}, {}): El argumento de 'entacar' ha de tener un valor"
          + "comprendido entre 0 y 255, ambos incluidos", t.beginLine, t.beginColumn);
      isThereASemanticError = true;
      return false;
    }
    return true;
  }

  public static boolean checkDivByZero(Expr right, Token op) {
    if (right.isConst && right.value == 0) {
      LOG.info("ERROR SEMÁNTICO({}, {}): Division por cero", op.beginLine, op.beginColumn);
      isThereASemanticError = true;
      return false;
    }
    return true;
  }

  public static boolean checkModuloZero(Expr right, Token op) {
    if (right.isConst && right.value == 0) {
      LOG.info("ERROR SEMÁNTICO({}, {}): Modulo cero", op.beginLine, op.beginColumn);
      isThereASemanticError = true;
      return false;
    }
    return true;
  }

  public static boolean checkIfItsAnAction(Token id) {
    Symbol sym = SymbolTable.getInstance().get(id.image);
    if (sym.isAction()) {
      return true;
    }
    LOG.info("ERROR SEMÁNTICO({}, {}): El simbolo no es una acción: \"{}\"",
        id.beginLine, id.beginColumn, id.image);
    isThereASemanticError = true;
    return false;
  }

  public static boolean checkNumArgsAndParams(Token id, int actualNumArgs) {
    Symbol sym = SymbolTable.getInstance().get(id.image);
    if (sym.getParameterList().size() != actualNumArgs) {
      LOG.info("ERROR SEMÁNTICO({}, {}): Número de argumentos ({}) es distinto al número de"
          + " parámetros ({}) para la acción: \"{}\"", id.beginLine, id.beginColumn, actualNumArgs,
          sym.getParameterList().size(), id.image);
      isThereASemanticError = true;
      return false;
    }
    return true;
  }

  private static void genExpDrf(Expr expr) {
    if (expr.isLValue) {
      gen.drf();
      if (expr.sym != null && expr.sym.isReference()) {
        gen.drf();
      }
    }
  }

  public static boolean wasThereAnError() {
    return isThereAParsingError || isThereASemanticError;
  }

  public static String getCodeAsString() {
    return gen.toString();
  }

  public static void writeCodeToFile(String filename) throws IOException {
    gen.writeToFile(filename);
  }

  public static boolean checkTypeOfUnaryOperator(Expr expr, Token t, Symbol.VariableType expectedType) {
    if (expr.type != expectedType && expr.type != Symbol.VariableType.UNK) {
      LOG.info("ERROR SEMÁNTICO({}, {}): La expresion ha de ser del tipo {}", t.beginLine, t.beginColumn, expectedType);
      isThereASemanticError = true;
      return false;
    }
    return true;
  }

  public static boolean checkTypesOfBinaryOperator(Expr left, Expr right,
      Symbol.VariableType typeOfBothOperands, Token operator) {
    if (left.type == right.type && left.type == typeOfBothOperands ||
          left.type == Symbol.VariableType.UNK || right.type == Symbol.VariableType.UNK) {
      return true;
    }
    LOG.info("ERROR SEMÁNTICO({}, {}): Los operandos del operador \"{}\" han de ser del tipo {}",
        operator.beginLine, operator.beginColumn, operator.image, typeOfBothOperands);
    isThereASemanticError = true;
    return false;
  }

  public static boolean checkTypesOfBinaryOperator(Expr left, Expr right, Token operator) {
    if (left.type == right.type || left.type == Symbol.VariableType.UNK ||
          right.type == Symbol.VariableType.UNK) {
      return true;
    }
    LOG.info("ERROR SEMÁNTICO({}, {}): Los operandos del operador \"{}\" han de ser del mismo tipo",
        operator.beginLine, operator.beginColumn, operator.image);
    isThereASemanticError = true;
    return false;
  }

  public static boolean checkBinaryOpForBoolCmp(Expr left, Expr right, Token op) {
    if (left.type == Symbol.VariableType.BOOL && op.kind != tIGUAL && op.kind != tNI) {
      LOG.info("ERROR SEMÁNTICO({}, {}): No se puede aplicar el operador \"{}\" a operandos del tipo booleano. Aplicar solo \"{}\" y \"{}\"",
      op.beginLine, op.beginColumn, op.image, "<>", "=");
      isThereASemanticError = true;
      return false;
    }
    return true;
  }

  private static CodeGenerator gen = new CodeGenerator();
  private static boolean isThereAParsingError = false;
  private static boolean isThereASemanticError = false;

}

PARSER_END(MiniLeng)

TOKEN_MGR_DECLS :
{
  private static TokenFreq tokenFreq = new TokenFreq();

  public static TokenFreq getTokenFreq() {
    return tokenFreq;
  }

  static void CommonTokenAction(Token t) {
    tokenFreq.addOrInc(t.kind);
  }
}

SKIP :
{
  " "
  | "\t"
  | "\n"
  | "\r"
  | "\r\n"
  | < tCOMENTARIOMULTI: "%%"(~[])*"%%" >
  | < tCOMENTARIO: "%"(~["\n","\r"])*("\n"|"\r"|"\r\n") >
}

// Data types
TOKEN :
{
  < tENTERO : "entero" >
  | < tBOOLEANO : "booleano" >
  | < tCARACTER : "caracter" >
}

// Arithmetic operators
TOKEN :
{
  < tMAS : "+" >
  | < tMENOS : "-" >
  | < tMUL : "*" >
  | < tDIVCHAR : "/" >
  | < tDIV : "div" >
  | < tMOD : "mod" >
}

// Asignment operators
TOKEN :
{
  < tOPAS : ":=" >
}

// Relational operators
TOKEN :
{
  < tMAYOR : ">" >
  | < tMENOR : "<" >
  | < tIGUAL : "=" >
  | < tMAI : ">=" >
  | < tMEI : "<=" >
  | < tNI : "<>" >
}

// Logical operators
TOKEN :
{
  < tAND : "and" >
  | < tOR : "or" >
  | < tNOT : "not" >
}

// Casting operators
TOKEN :
{
  < tENTACAR : "entacar" >
  | < tCARAENT : "caraent" >
}

// Conditional structures
TOKEN :
{
  < tSI : "si" >
  | < tENT : "ent" >
  | < tSI_NO : "si_no" >
  | < tFSI : "fsi" >
  | < tMQ : "mq" >
  | < tFMQ : "fmq" >
}

// IO
TOKEN :
{
  < tESCRIBIR : "escribir" >
  | < tLEER : "leer" >
}

// Procedure related tokens
TOKEN :
{
  < tVAL : "val" >
  | < tREF : "ref" >
  | < tACCION : "accion" >
  | < tPRINCIPIO : "principio" >
  | < tFIN : "fin" >
}

// Constants
TOKEN :
{
  < tTRUE : "true" >
  | < tFALSE : "false" >
  | < tKENTERO : (["0"-"9"])+ >
  | < tKCARACTER: "\""(~["\n","\r"])"\"" >
  | < tKCADENA: "\""(~["\n","\r","\""])(~["\n","\r","\""])+"\"" >
  | < tPUNTOCOMA : ";" >
  | < tCOMA : "," >
  | < tPAR_DCHA : ")" >
  | < tPAR_IZQ : "(" >
}

// Program
TOKEN :
{
  < tPROGRAMA : "programa" >
  | < tID : (["a"-"z"]) | (["a"-"z","_"](["a"-"z","0"-"9","_"])*(["a"-"z","0"-"9"])+) >
}

// Error
TOKEN :
{
  < tERROR : ~[] >
  {
    if (true) {
      throw new UnknownTokenException(
          "ERROR LÉXICO (" + matchedToken.beginLine + ", " + matchedToken.beginColumn
              + "): símbolo no reconocido: " + image);
    }
  }
}

void programa() :
{
  Token p;
  String mainLabel;
  IntWrapper freeAddress = new IntWrapper();
}

{
  try {
    {
      isThereAParsingError = false;
      isThereASemanticError = false;
      gen.reinit();
      mainLabel = gen.newLabel();
      gen.enp(mainLabel);
    }
    <tPROGRAMA> { SymbolTable.getInstance().openScope(); }
    p = <tID> { SymbolTable.getInstance().putProgram(p.image); }
    <tPUNTOCOMA> declaracion_variables(freeAddress) declaracion_acciones()
    {gen.insertLabel(mainLabel);} bloque_sentencias(freeAddress) <EOF>
    {
      SymbolTable.getInstance().closeScope();
      gen.lvp();
    }
  } catch (UnknownTokenException e) {
    LOG.info(e.getMessage());
  } catch (ParseException e) {
    recoverParsingError("programa", e);
  }
}

void declaracion_variables(IntWrapper addr) :
{
}

{
  try {
    declaracion(addr) <tPUNTOCOMA> declaracion_variables(addr) | {}
  } catch (ParseException e) {
    recoverParsingError("declaracion_variables", e);
  }
}

void declaracion(IntWrapper addr) :
{
  Symbol.VariableType variableType;
  List<Token> tokens;
}

{
  try {
    variableType = tipo_variables() tokens = identificadores()
    {
      for (Token id : tokens) {
          if(null == SymbolTable.getInstance().putVariable(id.image, variableType, addr.value++)) {
            LOG.info("ERROR SEMÁNTICO({}, {}): Simbolo ya declarado previamente: \"{}\"",
                id.beginLine, id.beginColumn, id.image);
            isThereASemanticError = true;
          }
      }
    }
  } catch (ParseException e) {
    recoverParsingError("declaracion", e);
  }
}

Symbol.VariableType tipo_variables() :
{
  Token t = null;
}

{
  try {
    t = <tENTERO> | t = <tCARACTER> | t = <tBOOLEANO>
  } catch (ParseException e) {
    recoverParsingError("tipo_variables", e);
  }
  { return t == null ? null : toVariableType(t.kind); }
}

List<Token> identificadores() :
{
  List<Token> tokens = new ArrayList<Token>();
  List<Token> tokensRep;
  Token id;
}

{
  try {
    id = <tID> {tokens.add(id);}
    tokensRep = repeticion_identificadores() {tokens.addAll(tokensRep);}
  } catch (ParseException e) {
    recoverParsingError("identificadores", e);
    tokens = new ArrayList<Token>();
  }
  {return tokens;}
}

List<Token> repeticion_identificadores() :
{
  List<Token> tokens = new ArrayList<Token>();
  List<Token> tokensRep;
  Token id;
}

{
  try {
    <tCOMA> id = <tID> {tokens.add(id);}
    tokensRep = repeticion_identificadores() {tokens.addAll(tokensRep);}
    | {}
  } catch (ParseException e) {
    recoverParsingError("repeticion_identificadores", e);
    tokens = new ArrayList<Token>();
  }
  {return tokens;}
}

void declaracion_acciones() :
{
}

{
  try {
    declaracion_accion() declaracion_acciones() | {}
  } catch (ParseException e) {
    recoverParsingError("declaracion_acciones", e);
  }
}

void declaracion_accion() :
{
  IntWrapper addr = new IntWrapper();
}

{
  try {
    cabecera_accion(addr) <tPUNTOCOMA> declaracion_variables(addr)
    declaracion_acciones() bloque_sentencias(addr)
    {
      gen.csf();
      SymbolTable.getInstance().closeScope();
    }
  } catch (ParseException e) {
    recoverParsingError("declaracion_accion", e);
  }
}

void cabecera_accion(IntWrapper addr) :
{
  List<ParamsInfo> params;
  Token actionId = null;
  int currentScope = SymbolTable.getInstance().getCurrentScope();
}

{
  try {
    <tACCION> actionId = <tID> params = parametros_formales()
    {
      List<Symbol> paramSyms = new ArrayList<Symbol>();
      for (ParamsInfo paramsInfo : params) {
        for (Token idToken : paramsInfo.idTokens) {
          // The scope and the address doesn't really matter here
          Symbol param = Symbol.buildParameter(idToken.image, paramsInfo.varType,
              paramsInfo.parType, currentScope + 1, addr.value++);
          paramSyms.add(param);
        }
      }
      if(null == SymbolTable.getInstance().putAction(actionId.image, paramSyms,
          gen.getInstrCount())) {
        LOG.info("ERROR SEMÁNTICO({}, {}): Simbolo ya declarado previamente: \"{}\"",
            actionId.beginLine, actionId.beginColumn, actionId.image);
        isThereASemanticError = true;
      }
      SymbolTable.getInstance().openScope();
      {
        int i = 0;
        for (ParamsInfo paramsInfo : params) {
          for (Token idToken : paramsInfo.idTokens) {
            if (SymbolTable.getInstance().putSymbol(paramSyms.get(i++)) == null) {
              LOG.info("ERROR SEMÁNTICO({}, {}): Simbolo ya declarado previamente: \"{}\"",
                  idToken.beginLine, idToken.beginColumn, idToken.image);
              isThereASemanticError = true;
            }
          }
        }
      }
      gen.comment("Accion: " + actionId.image);
      for (int i = paramSyms.size() - 1; i >= 0; --i) {
        Symbol s = paramSyms.get(i);
        gen.srf(0, s.getAddress());
        gen.asgi();
      }
    }
  } catch (ParseException e) {
    recoverParsingError("cabecera_accion", e);
  }
}

List<ParamsInfo> parametros_formales() :
{
  List<ParamsInfo> ids;
}

{
  try {
    <tPAR_IZQ> ids = lista_parametros() <tPAR_DCHA>
    | {} {ids = new ArrayList<ParamsInfo>();}
  } catch (ParseException e) {
    recoverParsingError("parametros_formales", e);
    ids = new ArrayList<ParamsInfo>();
  }
  {return ids;}
}

List<ParamsInfo> lista_parametros() :
{
  List<ParamsInfo> paramsInfoList = new ArrayList<ParamsInfo>();
  List<ParamsInfo> paramsInfoRepList;
  ParamsInfo paramsInfo;
}

{
  try {
    paramsInfo = parametro() {paramsInfoList.add(paramsInfo);}
    paramsInfoRepList = repeticion_parametro()
    {paramsInfoList.addAll(paramsInfoRepList);}
    | {} {paramsInfoList = new ArrayList<ParamsInfo>();}
  } catch (ParseException e) {
    recoverParsingError("lista_parametros", e);
    paramsInfoList = new ArrayList<ParamsInfo>();
  }
  {return paramsInfoList;}
}

ParamsInfo parametro() :
{
  ParamsInfo paramsInfo = new ParamsInfo();
}

{
  try {
    paramsInfo.parType = clase_parametros()
    paramsInfo.varType = tipo_variables()
    paramsInfo.idTokens = identificadores()
  } catch (ParseException e) {
    recoverParsingError("parametro", e);
    paramsInfo = new ParamsInfo();
  }
  {return paramsInfo;}
}

List<ParamsInfo> repeticion_parametro() :
{
  List<ParamsInfo> paramsInfoList = new ArrayList<ParamsInfo>();
  List<ParamsInfo> paramsInfoRepList;
  ParamsInfo paramsInfo;
}

{
  try {
    <tPUNTOCOMA> paramsInfo = parametro() {paramsInfoList.add(paramsInfo);}
    paramsInfoRepList = repeticion_parametro() {paramsInfoList.addAll(paramsInfoRepList);}
    | {} {paramsInfoList = new ArrayList<ParamsInfo>();}
  } catch (ParseException e) {
    recoverParsingError("repeticion_parametro", e);
    paramsInfoList = new ArrayList<ParamsInfo>();
  }
  {return paramsInfoList;}
}

Symbol.ParameterType clase_parametros() :
{
  Symbol.ParameterType parameterType = null;
}

{
  try {
    <tVAL> {parameterType = Symbol.ParameterType.VAL;}
    | <tREF> {parameterType = Symbol.ParameterType.REF;}
  } catch (ParseException e) {
    recoverParsingError("clase_parametros", e);
  }
  {return parameterType;}
}

void bloque_sentencias(IntWrapper freeAddress) :
{
}

{
  try {
    <tPRINCIPIO> lista_sentencias(freeAddress) <tFIN>
  } catch (ParseException e) {
    recoverParsingError("bloque_sentencias", e);
  }
}

void lista_sentencias(IntWrapper freeAddress) :
{
}

{
  try {
    sentencia(freeAddress) repeticion_lista_sentencias(freeAddress)
  } catch (ParseException e) {
    recoverParsingError("lista_sentencias", e);
  }
}

void repeticion_lista_sentencias(IntWrapper freeAddress) :
{
}

{
  try {
    sentencia(freeAddress) repeticion_lista_sentencias(freeAddress) | {}
  } catch (ParseException e) {
    recoverParsingError("repeticion_lista_sentencias", e);
  }
}

void sentencia(IntWrapper freeAddress) :
{
}

{
  try {
    leer() <tPUNTOCOMA> | escribir() <tPUNTOCOMA>
    | asignacion_invocacion(freeAddress) | seleccion(freeAddress)
    | mientras_que(freeAddress) | <tPUNTOCOMA>
  } catch (ParseException e) {
    recoverParsingError("sentencia", e);
  }
}

void leer() :
{
  List<Token> idTokens;
}

{
  try {
    <tLEER> <tPAR_IZQ> idTokens = identificadores()
    {
      for (Token id : idTokens) {
        if (checkIfSymbolExists(id)) {
          if (checkIfItsAssignable(id)) {
            Symbol idSym = SymbolTable.getInstance().get(id.image);
            gen.srf(0, idSym.getAddress());
            if (idSym.isReference()) {
              gen.drf();
            }
            gen.rd(idSym.getVariableType() == Symbol.VariableType.INT);
          }
        } else {
          SymbolTable.getInstance().putVariable(id.image, Symbol.VariableType.UNK, -1);
        }
      }
    }
    <tPAR_DCHA>
  } catch (ParseException e) {
    recoverParsingError("leer", e);
  }
}

void escribir() :
{
}

{
  try {
    <tESCRIBIR> <tPAR_IZQ> lista_argumentos_escribir() <tPAR_DCHA>
  } catch (ParseException e) {
    recoverParsingError("escribir", e);
  }
}

void asignacion_invocacion(IntWrapper freeAddress) :
{
  Token id;
}

{
  try {
    id = <tID> asignacion_invocacion_(id, freeAddress)
  } catch (ParseException e) {
    recoverParsingError("asignacion_invocacion", e);
  }
}

void asignacion_invocacion_(Token id, IntWrapper freeAddress) :
{
  int numArgs;
}

{
  try {
    asignacion(id)
    | invocacion_accion(freeAddress, id)
  } catch (ParseException e) {
    recoverParsingError("asignacion_invocacion_", e);
  }
}

void asignacion(Token id) :
{
  Symbol idSym = SymbolTable.getInstance().get(id.image);
  Expr expr;
  Token op;
}

{
  try {
    op = <tOPAS> expr = expresion_bool()
    {
      Expr left = new Expr();
      left.type = idSym.getVariableType();
      if (checkIfSymbolExists(id)) {
        if (checkIfItsAssignable(id) && checkTypesOfBinaryOperator(left, expr, left.type, op)) {
          genExpDrf(expr);
          int frame = SymbolTable.getInstance().getCurrentScope() - idSym.getScope();
          gen.srf(frame, idSym.getAddress());
          if (idSym.isReference()) {
            gen.drf();
          }
          gen.asgi();
        }
      } else {
        SymbolTable.getInstance().putVariable(id.image, Symbol.VariableType.UNK, -1);
      }
    }
    <tPUNTOCOMA>
  } catch (ParseException e) {
    recoverParsingError("asignacion", e);
  }
}

void invocacion_accion(IntWrapper freeAddress, Token id) :
{
  int numArgs;
  Symbol actionSym = null;
  boolean insertDummyActionSym = false;
  if (checkIfSymbolExists(id)) {
    if (checkIfItsAnAction(id)) {
      actionSym = SymbolTable.getInstance().get(id.image);
    }
  } else {
    insertDummyActionSym = true;
  }
}

{
  try {
    numArgs = argumentos_accion(freeAddress, actionSym) <tPUNTOCOMA>
    {
      if (insertDummyActionSym) {
        List<Symbol> dummyParams = new ArrayList<Symbol>();
        for (int i = 0; i < numArgs; ++i) {
          Symbol dummyParam = Symbol.buildParameter("dummy_" + i,
              Symbol.VariableType.UNK, Symbol.ParameterType.VAL, -1, -1);
          dummyParams.add(dummyParam);
        }
        SymbolTable.getInstance().putAction(id.image, dummyParams, -1);
      } else if (actionSym != null && checkNumArgsAndParams(id, numArgs)) {
        gen.osf(freeAddress.value,
            SymbolTable.getInstance().getCurrentScope() - actionSym.getScope(),
            actionSym.getAddress());
      }
    }
  } catch (ParseException e) {
    recoverParsingError("invocacion_accion", e);
    numArgs = 0;
  }
}

void mientras_que(IntWrapper freeAddress) :
{
  String startLoopLabel;
  String endLoopLabel;
  Expr expr;
}

{
  try {
    <tMQ> {startLoopLabel = gen.newLabel(); gen.insertLabel(startLoopLabel);}
    expr = expresion_bool()
    {
      genExpDrf(expr);
      endLoopLabel = gen.newLabel();
      gen.jmf(endLoopLabel);
    }
    lista_sentencias(freeAddress) {gen.jmp(startLoopLabel);}
    <tFMQ> {gen.insertLabel(endLoopLabel);}
  } catch (ParseException e) {
    recoverParsingError("mientras_que", e);
  }
}

void seleccion(IntWrapper freeAddress) :
{
}

{
  try {
    <tSI> seleccion_(freeAddress)
  } catch (ParseException e) {
    recoverParsingError("seleccion", e);
  }
}

int argumentos_accion(IntWrapper freeAddress, Symbol actionSym) :
{
  int numArgs = 0;
}

{
  try {
    <tPAR_IZQ> numArgs = lista_argumentos_vacia(freeAddress, actionSym)
    <tPAR_DCHA> | {}
  } catch (ParseException e) {
    recoverParsingError("argumentos_accion", e);
    numArgs = 0;
  }
  {return numArgs;}
}

void argumento_accion(Symbol actionSym, IntWrapper argPos) :
{
  Expr expr;
  Token t;
}

{
  try {
    {t = getToken(1);}
    expr = expresion_bool()
    {
      if (actionSym != null) {
        List<Symbol> params = actionSym.getParameterList();
        if (argPos.value < params.size()) {
          Symbol param = params.get(argPos.value);
          if (checkIfArgIsValid(expr, param, t) &&
                checkArgAndParamTypes(expr, param, t)) {
            if (expr.isLValue) {
              if (expr.sym.isReference()) {
                gen.drf();
              }
              if (!param.isReference()) {
                gen.drf();
              }
            }
          }
        }
      }
    }
  } catch (ParseException e) {
    recoverParsingError("argumento_accion", e);
  }
}

void argumento_escribir() :
{
  Token tCadena;
  Expr expr;
}

{
  try {
    tCadena = <tKCADENA>
    {
      String imageWoQuotes = tCadena.image.substring(0, tCadena.image.length() - 1);
      gen.writeString(imageWoQuotes);
    }
    | expr = expresion_bool()
    {
      if (expr.type == Symbol.VariableType.BOOL) {
        genExpDrf(expr);
        String lFalse = gen.newLabel();
        String lOut = gen.newLabel();
        gen.jmf(lFalse);
        gen.writeString("Verdadero");
        gen.jmp(lOut);
        gen.insertLabel(lFalse);
        gen.writeString("Falso");
        gen.insertLabel(lOut);
      } else {
        genExpDrf(expr);
        gen.wrt(expr.type == Symbol.VariableType.INT);
      }
    }
  } catch (ParseException e) {
    recoverParsingError("argumento_escribir", e);
  }
}

int lista_argumentos_vacia(IntWrapper freeAddress, Symbol actionSym) :
{
  IntWrapper argPos = new IntWrapper(0);
}

{
  try {
    argumento_accion(actionSym, argPos)
    repeticion_argumentos(freeAddress, actionSym, argPos)
    | {} {return 0;}
  } catch (ParseException e) {
    recoverParsingError("lista_argumentos_vacia", e);
    return 0;
  }
  {return argPos.value + 1;}
}

void lista_argumentos_escribir() :
{
  Token tCadena;
  Expr expr;
}

{
  try {
    argumento_escribir() repeticion_argumentos_escribir()
  } catch (ParseException e) {
    recoverParsingError("lista_argumentos_escribir", e);
  }
}

void repeticion_argumentos(IntWrapper freeAddress, Symbol actionSym,
    IntWrapper argPos) :
{
}

{
  try {
    <tCOMA> {argPos.value++;} argumento_accion(actionSym, argPos)
    repeticion_argumentos(freeAddress, actionSym, argPos) | {}
  } catch (ParseException e) {
    recoverParsingError("repeticion_argumentos", e);
  }
}

void repeticion_argumentos_escribir() :
{
}

{
  try {
    <tCOMA> argumento_escribir() repeticion_argumentos_escribir() | {}
  } catch (ParseException e) {
    recoverParsingError("repeticion_argumentos_escribir", e);
  }
}

Token operador_relacional() :
{
  Token t = null;
}

{
  try {
    t = <tMAYOR> | t = <tMENOR> | t = <tIGUAL> | t = <tMAI> | t = <tMEI>
    | t = <tNI>
  } catch (ParseException e) {
    recoverParsingError("operador_relacional", e);
  }
  {return t;}
}

Expr caraent() :
{
  Expr expr = new Expr();
  Token t;
}

{
  try {
    t = <tCARAENT> <tPAR_IZQ> expr = expresion_bool() <tPAR_DCHA>
    {
      checkCaraentArg(expr, t);
    }
  } catch (ParseException e) {
    recoverParsingError("caraent", e);
  }
  {
    expr.type = Symbol.VariableType.INT;
    return expr;
  }
}

Expr entacar() :
{
   Expr expr = new Expr();
   Token t;
}

{
  try {
    t = <tENTACAR> <tPAR_IZQ> expr = expresion_bool()
    {
      if (checkEntacarArgType(expr, t) &&
            checkEntacarArgConstValue(expr, t)) {
        genExpDrf(expr);
      }
    }
    <tPAR_DCHA>
  } catch (ParseException e) {
    recoverParsingError("entacar", e);
  }
  {
    expr.type = Symbol.VariableType.CHAR;
    return expr;
  }
}

Expr expresion_bool() :
{
  Expr constexprTermBool = new Expr();
  Expr constexprExpresionBool = new Expr();
}

{
  try {
    constexprTermBool = expresion_bool_simple()
    constexprExpresionBool = expresion_bool_(constexprTermBool)
  } catch (ParseException e) {
    recoverParsingError("expresion_bool", e);
  }
  {return constexprExpresionBool;}
}

Expr expresion_bool_simple() :
{
  Expr term = new Expr();
  Expr expBool = new Expr();
}

{
  try {
    term = term_bool() expBool = expresion_bool_simple_(term)
  } catch (ParseException e) {
    recoverParsingError("expresion_bool_simple", e);
  }
  {return expBool;}
}

Expr term_bool() :
{
  Expr factor = new Expr();
  Expr term = new Expr();
}

{
  try {
    factor = expresion_arit() term = term_bool_(factor)
  } catch (ParseException e) {
    recoverParsingError("term_bool", e);
  }
  {return term;}
}

Expr expresion_arit() :
{
  Expr term = new Expr();
  Expr expArit = new Expr();
}

{
  try {
    term = term_arit() expArit = expresion_arit_(term)
  } catch (ParseException e) {
    recoverParsingError("expresion_arit", e);
  }
  {return expArit;}
}

Expr term_arit() :
{
  Expr factor = new Expr();
  Expr term = new Expr();
}

{
  try {
    factor = factor_arit_unario() term = term_arit_(factor)
  } catch (ParseException e) {
    recoverParsingError("term_arit", e);
  }
  {return term;}
}

Expr factor_arit_unario() :
{
  Expr expr = new Expr();
  Token t;
}

{
  try {
    t = <tMAS> expr = factor_arit()
    {
      checkTypeOfUnaryOperator(expr, t.next, Symbol.VariableType.INT);
    }
    | t = <tMENOS> expr = factor_arit()
    {
      expr.value = -1 * expr.value;
      expr.isLValue = false;
      checkTypeOfUnaryOperator(expr, t.next, Symbol.VariableType.INT);
      genExpDrf(expr);
      gen.ngi();
    }
    | t = <tNOT> expr = factor_arit()
    {
      checkTypeOfUnaryOperator(expr, t.next, Symbol.VariableType.BOOL);
      expr.value = expr.value != 0 ? 0 : 1;
      expr.isLValue = false;
      genExpDrf(expr);
      gen.ngb();
    }
    | expr = factor_arit()
  } catch (ParseException e) {
    recoverParsingError("factor_arit_unario", e);
  }
  {return expr;}
}

Expr factor_arit() :
{
  Token id;
  Expr expr = new Expr();
}

{
  try {
    <tFALSE>
    {
      expr.isConst = true;
      expr.value = 0;
      expr.type = Symbol.VariableType.BOOL;
      gen.stc(0);
    }
    | <tTRUE>
    {
      expr.isConst = true;
      expr.value = 1;
      expr.type = Symbol.VariableType.BOOL;
      gen.stc(1);
    }
    | id = <tKENTERO>
    {
      expr.isConst = true;
      expr.value = Integer.valueOf(id.image);
      expr.type = Symbol.VariableType.INT;
      gen.stc(expr.value);
    }
    | id = <tID>
    {
      if (checkIfSymbolExists(id)) {
        if (checkIfItsVarOrParam(id)) {
          Symbol symId = SymbolTable.getInstance().get(id.image);
          expr.isLValue = true;
          expr.sym = symId;
          expr.type = symId.getVariableType();
          gen.srf(SymbolTable.getInstance().getCurrentScope() - symId.getScope(),
              symId.getAddress());
        }
      } else {
        SymbolTable.getInstance().putVariable(id.image, Symbol.VariableType.UNK, -1);
      }
    }
    | id = <tKCARACTER>
    {
      expr.isConst = true;
      expr.value = id.image.charAt(1);
      expr.type = Symbol.VariableType.CHAR;
      gen.stc(expr.value);
    }
    | <tPAR_IZQ> expr = expresion_bool() {genExpDrf(expr);} <tPAR_DCHA>
    | expr = entacar()
    | expr = caraent()
  } catch (ParseException e) {
    recoverParsingError("factor_arit", e);
  }
  {return expr;}
}

Expr expresion_bool_(Expr inherit) :
{
  Expr expr = new Expr();
  expr.type = Symbol.VariableType.BOOL;
  Expr term = new Expr();
  Expr exp = new Expr();
  exp.type = Symbol.VariableType.BOOL;
  Token op;
}

{
  try {
    op = operador_relacional() {genExpDrf(inherit);}
    term = expresion_bool_simple()
    {
      if (checkTypesOfBinaryOperator(inherit, term, op) &&
          checkBinaryOpForBoolCmp(inherit, term, op)) {
        genExpDrf(term);
        expr.value = relation(op, inherit.value, term.value) ? 1 : 0;
        expr.isConst = inherit.isConst && term.isConst;
        switch (op.kind ) {
          case tMAYOR:
            gen.gt();
            break;
          case tMENOR:
            gen.lt();
            break;
          case tIGUAL:
            gen.eq();
            break;
          case tMAI:
            gen.gte();
            break;
          case tMEI:
            gen.lte();
            break;
          case tNI:
            gen.neq();
            break;
          default:
            gen.nop();
        }
      }
    }
    exp = expresion_bool_(expr)
    | {} {exp = inherit;}
  } catch (ParseException e) {
    recoverParsingError("expresion_bool_", e);
  }
  {return exp;}
}

Expr expresion_bool_simple_(Expr inherit) :
{
  Expr expr = new Expr();
  expr.type = Symbol.VariableType.BOOL;
  Expr term = new Expr();
  Expr exp = new Expr();
  exp.type = Symbol.VariableType.BOOL;
  Token op;
}

{
  try {
    op = <tOR> {genExpDrf(inherit);}
    term = term_bool()
    {
      if (checkTypesOfBinaryOperator(inherit, term, Symbol.VariableType.BOOL, op)) {
        expr.isConst = inherit.isConst && term.isConst;
        expr.value = (inherit.value != 0) || (exp.value != 0) ? 1 : 0;
        genExpDrf(term);
        gen.or();
      }
    }
    exp = expresion_bool_simple_(expr)
    | {} {exp = inherit;}
  } catch (ParseException e) {
    recoverParsingError("expresion_bool_simple_", e);
  }
  {return exp;}
}


Expr term_bool_(Expr inherit) :
{
  Expr expr = new Expr();
  expr.type = Symbol.VariableType.BOOL;
  Expr factor = new Expr();
  Expr term = new Expr();
  term.type = Symbol.VariableType.BOOL;
  Token op;
}

{
  try {
    op = <tAND> {genExpDrf(inherit);}
    factor = expresion_arit()
    {
      if (checkTypesOfBinaryOperator(inherit, factor, Symbol.VariableType.BOOL, op)) {
        expr.isConst = inherit.isConst && factor.isConst;
        expr.value = (inherit.value != 0) && (term.value != 0) ? 1 : 0;
        genExpDrf(factor);
        gen.and();
      }
    }
    term = term_bool_(expr)
    | {} {term = inherit;}
  } catch (ParseException e) {
    recoverParsingError("term_bool_", e);
  }
  {return term;}
}

Expr expresion_arit_(Expr inherit) :
{
  Expr expr = new Expr();
  expr.type = Symbol.VariableType.INT;
  Expr term = new Expr();
  Expr exp = new Expr();
  exp.type = Symbol.VariableType.INT;
  Token op;
}

{
  try {
    op = <tMAS> {genExpDrf(inherit);}
    term = term_arit()
    {
      if (checkTypesOfBinaryOperator(inherit, term, Symbol.VariableType.INT, op)) {
        expr.isConst = inherit.isConst && term.isConst;
        expr.value = inherit.value + term.value;
        genExpDrf(term);
        gen.plus();
      }
    }
    exp = expresion_arit_(expr)
    | op = <tMENOS> {genExpDrf(inherit);}
    term = term_arit()
    {
      if (checkTypesOfBinaryOperator(inherit, term, Symbol.VariableType.INT, op)) {
        expr.isConst = inherit.isConst && term.isConst;
        expr.value = inherit.value - term.value;
        genExpDrf(term);
        gen.sbt();
      }
    }
    exp = expresion_arit_(expr)
    | {} {exp = inherit;}
  } catch (ParseException e) {
    recoverParsingError("expresion_arit_", e);
  }
  {
    return exp;
  }
}

Expr term_arit_(Expr inherit) :
{
    Expr expr = new Expr();
    expr.type = Symbol.VariableType.INT;
    Expr factor = new Expr();
    Expr term = new Expr();
    term.type = Symbol.VariableType.INT;
    Token op = null;
}

{
  try {
    op = <tMUL> {genExpDrf(inherit);}
    factor = factor_arit_unario()
    {
      if (checkTypesOfBinaryOperator(inherit, factor, Symbol.VariableType.INT, op)) {
        expr.isConst = (inherit.isConst && inherit.value == 0) ||
            (factor.isConst && factor.value == 0) ||
            (inherit.isConst && factor.isConst);
        expr.value = inherit.value * factor.value;
        genExpDrf(factor);
        gen.tms();
      }
    }
    term = term_arit_(expr)
    | (op = <tDIV> | op = <tDIVCHAR>) {genExpDrf(inherit);}
    factor = factor_arit_unario()
    {
      if (checkTypesOfBinaryOperator(inherit, factor, Symbol.VariableType.INT, op)) {
        if (checkDivByZero(factor, op)) {
          expr.isConst = (inherit.isConst && inherit.value == 0) ||
              (inherit.isConst && factor.isConst);
          expr.value = inherit.value / factor.value;
          genExpDrf(factor);
          gen.div();
        }
      }
    }
    term = term_arit_(expr)
    | op = <tMOD> {genExpDrf(inherit);}
    factor = factor_arit_unario()
    {
      if (checkTypesOfBinaryOperator(inherit, factor, Symbol.VariableType.INT, op)) {
        if (checkModuloZero(factor, op)) {
          expr.isConst = (inherit.isConst && inherit.value == 0) ||
              (inherit.isConst && factor.isConst);
          expr.value = inherit.value % factor.value;
          genExpDrf(factor);
          gen.mod();
        }
      }
    }
    term = term_arit_(factor)
    | {} {term = inherit;}
  } catch (ParseException e) {
    recoverParsingError("term_arit_", e);
  }
  {
    return term;
  }
}

void seleccion_(IntWrapper freeAddress) :
{
  Expr expr;
}
{
  try {
    expr = expresion_bool()
    {
      genExpDrf(expr);
      String labelFalse = gen.newLabel();
      gen.jmf(labelFalse);
    }
    seleccion__(labelFalse, freeAddress)
  } catch (ParseException e) {
    recoverParsingError("seleccion_", e);
  }
}

void seleccion__(String labelFalse, IntWrapper freeAddress) :
{
}

{
  try {
    <tENT> seleccion___(labelFalse, freeAddress)
  } catch (ParseException e) {
    recoverParsingError("seleccion__", e);
  }
}

void seleccion___(String labelFalse, IntWrapper freeAddress) :
{
}

{
  try {
    lista_sentencias(freeAddress) seleccion____(labelFalse, freeAddress)
  } catch (ParseException e) {
    recoverParsingError("seleccion___", e);
  }
}

void seleccion____(String labelFalse, IntWrapper freeAddress) :
{
}

{
  try {
    <tFSI> {gen.insertLabel(labelFalse);}
    | {String l = gen.newLabel(); gen.jmp(l);}
    <tSI_NO> {gen.insertLabel(labelFalse);} lista_sentencias(freeAddress)
    <tFSI> {gen.insertLabel(l);}
  } catch (ParseException e) {
    recoverParsingError("seleccion____", e);
  }
}
